<!DOCTYPE html>
<html lang="en" ng-app="jpm">

	<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="/css/style.css" rel="stylesheet" />
<title>Contracts</title>

	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			<style>
				 body {
					counter-reset: h1 11;
				}
			</style>
				
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	

</head>


<body>

	
<ul class="container12 menu-bar">
	<li span=8><a class=menu-link href="/"><img
			class=menu-logo src='/img/bnd-80x40-white.png'></a>
			<a href="/chapters/110-introduction.html">Intro
			</a><a href="/chapters/800-headers.html">Headers
			</a><a href="/chapters/820-instructions.html">Instructions
			</a><a href="/chapters/850-macros.html">Macros</a>
			
	<li class=menu-link span=4>
			<a href="https://github.com/bndtools/bnd" target="_"><img
	style="position:absolute;top:0;right:0;margin:0;padding:0;z-index:100"
	src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67"
	alt="Fork me on GitHub"
	data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
</ul>


					

	<ul class=container12>
		<li span=3>
			<div>
			<ul class="side-nav">
	
		
			<li><a href="/chapters/110-introduction.html">Introduction</a>
	  	
  	
		
			<li><a href="/chapters/120-install.html">Where to find it</a>
	  	
  	
		
			<li><a href="/chapters/125-quick-start.html">Quick Start</a>
	  	
  	
		
			<li><a href="/chapters/130-concepts.html">Concepts</a>
	  	
  	
		
			<li><a href="/chapters/140-best-practices.html">Best practices</a>
	  	
  	
		
			<li><a href="/chapters/150-build.html">Build</a>
	  	
  	
		
			<li><a href="/chapters/160-jars.html">Generating JARs</a>
	  	
  	
		
			<li><a href="/chapters/170-versioning.html">Versioning</a>
	  	
  	
		
			<li><a href="/chapters/200-components.html">Service Components</a>
	  	
  	
		
			<li><a href="/chapters/210-metatype.html">Metatype</a>
	  	
  	
		
			<li class=selected>Contracts
	  	
  	
		
			<li><a href="/chapters/300-launching.html">Launching</a>
	  	
  	
		
			<li><a href="/chapters/310-testing.html">Testing</a>
	  	
  	
		
			<li><a href="/chapters/320-packaging.html">Packaging Applications</a>
	  	
  	
		
			<li><a href="/chapters/400-commandline.html">From the command line</a>
	  	
  	
		
			<li><a href="/chapters/600-developer.html">For Developers</a>
	  	
  	
		
			<li><a href="/chapters/700-tools.html">Tools bound to bnd</a>
	  	
  	
		
			<li><a href="/chapters/790-format.html">File Format</a>
	  	
  	
		
			<li><a href="/chapters/800-headers.html">Header Reference</a>
	  	
  	
		
			<li><a href="/chapters/820-instructions.html">Instruction Reference</a>
	  	
  	
		
			<li><a href="/chapters/850-macros.html">Macro Reference</a>
	  	
  	
		
			<li><a href="/chapters/860-commands.html">Command Reference</a>
	  	
  	
		
			<li><a href="/chapters/880-settings.html">Settings</a>
	  	
  	
		
			<li><a href="/chapters/900-errors.html">Errors</a>
	  	
  	
		
			<li><a href="/chapters/910-faq.html">Frequently Asked Questions</a>
	  	
  	
</ul>

			<div class=enroute><a href="http://enroute.osgi.org">Supported by OSGi enRoute <img src="/img/EnRouteIcon_CMYK.png"></a></div>
			</div>
			
		<li span=9>
			<div class=notes-margin>
				<h1> Contracts</h1>
				<p>The OSGi has a very elegant package version model there are still many that think this is too much work. They do not want to be bothered by the niceties of semantic versions and just want to use, let’s say, Servlet 3.0. For those people (seemingly not interested in minimizing dependencies) the OSGi Alliance came up with contracts in OSGi Core, Release 5.0.0. A contract allows you to: </p>

<ul>
  <li>Declare that a bundle provides the API of the given specification</li>
  <li>Require that the API comes from a bundle that made the declaration</li>
</ul>

<p>This very common pattern is called the Capability/Requirement (C/R) model in OSGi, it underlies all of its dependency concepts like Import/Export package and others; it forms the foundation of the OSGi Bundle Repository. If you ever want to know what is happening deep down inside a framework than look at the Wiring API and you see the requirements and capabilities in their most fundamental form. </p>

<p>Capabilities declare a set of properties that describe something that a bundle can provide. A Requirement in a bundle has a filter that must match a capability before this bundle can be resolved. To prevent requirements matching completely unrelated capabilities they must both be defined in the same namespace,, where the namespace then defines the semantics of the properties. Using the C/R model we were able to describe most of the OSGi dependencies with surprisingly few additional concepts. For a modern OSGi resolver there is very little difference between the Import-Package and Require-Bundle headers. </p>

<p>So how do those contracts work? Well, the bundle that provides the API for the contract has a contract capability. What this means is that it provides a Provide-Capability clause in the osgi.contract namespace, for example: </p>

<pre><code>Bundle P:
  Provide-Capability: 
     osgi.contract;
      osgi.contract=Servlet;
      uses:="javax.servlet,javax.servlet.http";
      version="3.0"
  Export-Package: javax.servlet, javax.servlet.http
</code></pre>

<p>This contract defines two properties, the contract name (by convention this is the namespace name as property key) and the version. A bundle that wants to rely on this API can add the following requirement to its manifest: 
Bundle R:</p>

<pre><code>  Require-Capability: osgi.contract;
    filter:="(&amp;(osgi.contract=Servlet)(version=3.0))"
  Import-Package: javax.servlet, javax.servlet.http
</code></pre>

<p>Experienced OSGi users should have cringed at these versionless packages, cringing becomes a gut-reaction at the sight of versionless packages. However, in this case it actually cannot harm. The previous example will ensure that Bundle P will be the class loader for the Bundle R for packages javax.servlet, javax.servlet.http. The magic is in the uses: directive, if the Require-Capability in bundle R is resolved to the Provide-Capability in bundle P then bundle R must import these packages from bundle P.</p>

<p>Obviously bnd has support for this (well, since today, i.e. version osgi:biz.aQute.bndlib@2.2.0.20130806-071947 or later). First bnd can make it easier to create the Provide Capability header since the involved packages are in the Export-Package as well as in the Provide-Capability headers. The do-no-repeat-yourself mantra dictated am ${exports} macro. The ${exports} macro is replaced by the exported packages of the bundle, for example: 
Bundle P:</p>

<pre><code>  Provide-Capability: 
    osgi.contract;
      osgi.contract=Servlet;
      uses:="${exports}";
      version="3.0"
  Export-Package: javax.servlet, javax.servlet.http
</code></pre>

<p>That said, the most extensive help you get from bnd is for requiring contracts. Providing a contract is not so cumbersome, after all you’re the provider so you have all the knowledge and the interest in providing metadata. Consuming a contract is less interesting and it is much harder to get the metadata right. In a similar vein, bnd analyzes your classes to find out the dependencies to create the Import-Package statement, doing this by hand is really hard (as other OSGi developing environments can testify!). </p>

<p>So to activate the use of contracts, add the -contract instruction: </p>

<pre><code>bnd.bnd:
  -contract: *
</code></pre>

<p>This instruction will give bnd permission to scan the build path for contracts, i.e. Provide-Capability clauses in the osgi.contract namespace. These declared contracts cause a corresponding requirement in the bundle when the bundle imports packages listed in the uses clause. In the example with Bundle R, bnd will automatically insert the Require-Capability header and remove any versions on the imported packages. 
Sometimes the wildcard for the -contract instruction can be used to limit the contracts that are considered. Sometimes you want a specific contract but not others. Other times you want to skip a specific contract. The following example skips the ‘Servlet’ contract: 
bnd.bnd:</p>

<pre><code>  -contract: !Servlet,*
</code></pre>

<p>The tests provide some examples for people that want to have a deeper understanding: https://github.com/bndtools/bnd/blob/next/biz.aQute.bndlib.tests/src/test/ContractTest.java Contracts will be part of the bnd(tools) 2.2 release (hopefully) at the end of this summer, until then they are experimental. Enjoy. Peter Kriens @pkriens Update: Last example to skip the ‘Servlet’ contract was reversed, updated the text to show a reverse example (anything BUT Servlet).</p>

			</div>
	</ul>

	
<nav class=next-prev>
	<a href=''></a> <a href=''></a>
</nav>
<footer class="container12" style="border-top: 1px solid black;padding:10px 0">
	<ul span=12 row>
		<li span=3>
			<ul>
				<li><a href="/contact.html">Contact</a>
			</ul>
		<li span=3>
			<ul>
				<li><a href="">Developers</a>
			</ul>
		<li span=3>
			<ul>
				<li><a href="">More</a>
			</ul>
	</ul>
</footer>

</body>
</html>
